image: mcr.microsoft.com/dotnet/sdk:8.0

stages:
  - build
  - test
  - report
  - monitoring
  - deploy

services:
  - name: selenium/standalone-chrome:latest
    alias: selenium-standalone

build-job:
  stage: build
  script:
    - echo "Compiling the code..."
    - echo "Compile complete."

dotnet-test:
  stage: test
  script:
    - dotnet restore
    - dotnet test StepikTesting.sln --logger "trx" --results-directory TestResults
  artifacts:
    when: always
    reports:
      junit:
        - TestResults/*.trx
    paths:
      - TestResults/
    expire_in: 1 week
  allow_failure: true

allure-report:
  image: openjdk:11-jdk
  stage: report
  before_script:
    - apt-get update && apt-get install -y wget unzip
    - wget https://github.com/allure-framework/allure2/releases/download/2.21.0/allure-2.21.0.zip
    - unzip allure-2.21.0.zip -d /opt/
    - ln -s /opt/allure-2.21.0/bin/allure /usr/local/bin/allure
  script:
    - allure generate TestResults --clean -o allure-report
    - |
      mkdir -p allure-report/data
      cat > allure-report/data/environment.json << EOF
      {
        "allure": {
          "directory": "allure-results",
          "links": [],
          "environment": {
            "runtime": "net8.0",
            "allure_version": "2.21.0",
            "specflow_version": "3.9.74"
          }
        }
      }
      EOF
  artifacts:
    paths:
      - allure-report/
    expire_in: 1 week
  dependencies:
    - dotnet-test

monitoring:
  image: docker:latest
  stage: monitoring
  services:
    - docker:dind
  before_script:
    - apk add --no-cache docker-compose curl jq
  script:
    - |
      # Start docker-compose with explicit project name
      echo "Starting monitoring stack..."
      docker-compose -f docker-compose.yml -p stepiktesting up -d
      
      # Wait for services to be ready
      echo "Waiting for services to start..."
      sleep 10
      
      # Check container status
      echo "=== Container Status ==="
      docker-compose -p stepiktesting ps
      
      # Get the actual network name
      NETWORK_NAME=$(docker network ls --filter name=stepiktesting --format "{{.Name}}")
      echo "Using network: $NETWORK_NAME"
      
      # Test connectivity from within the containers
      echo "=== Testing Container Connectivity ==="
      
      # Test Prometheus from within its own container
      echo "Testing Prometheus from inside container..."
      docker exec prometheus wget -q -O- http://localhost:9090/-/ready && echo "✓ Prometheus is healthy internally" || echo "✗ Prometheus internal health check failed"
      
      # Test Grafana from within its own container
      echo "Testing Grafana from inside container..."
      docker exec grafana wget -q -O- http://localhost:3000/api/health && echo "✓ Grafana is healthy internally" || echo "✗ Grafana internal health check failed"
      
      # Test inter-container communication
      echo "Testing Prometheus -> Grafana communication..."
      docker exec prometheus wget -q -O- http://grafana:3000/api/health > /dev/null && echo "✓ Prometheus can reach Grafana" || echo "✗ Prometheus cannot reach Grafana"
      
      echo "Testing Grafana -> Prometheus communication..."
      docker exec grafana wget -q -O- http://prometheus:9090/-/ready > /dev/null && echo "✓ Grafana can reach Prometheus" || echo "✗ Grafana cannot reach Prometheus"
      
      # Test external access using container IPs
      echo "=== Testing External Access via Container IPs ==="
      PROMETHEUS_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' prometheus)
      GRAFANA_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' grafana)
      
      echo "Prometheus IP: $PROMETHEUS_IP"
      echo "Grafana IP: $GRAFANA_IP"
      
      echo "Testing Prometheus at http://$PROMETHEUS_IP:9090..."
      curl -s --connect-timeout 10 http://$PROMETHEUS_IP:9090/-/ready > /dev/null && echo "✓ Prometheus accessible via container IP" || echo "✗ Prometheus not accessible via container IP"
      
      echo "Testing Grafana at http://$GRAFANA_IP:3000..."
      curl -s --connect-timeout 10 http://$GRAFANA_IP:3000/api/health > /dev/null && echo "✓ Grafana accessible via container IP" || echo "✗ Grafana not accessible via container IP"
      
      # Check if ports are actually bound
      echo "=== Checking Port Bindings ==="
      netstat -tulpn || ss -tulpn || echo "Cannot check port bindings"
      
      # Check Docker port mappings
      echo "Docker port mappings:"
      docker port prometheus
      docker port grafana
      
      # Debug: Check what's listening on ports
      echo "=== Checking listening processes ==="
      ps aux | grep docker
      
      # Test localhost access (this might not work in dind)
      echo "=== Testing Localhost Access ==="
      echo "Note: In docker-in-docker, localhost might not work as expected"
      
      # Alternative: Use host.docker.internal if available
      echo "Testing host.docker.internal..."
      curl -s --connect-timeout 10 http://host.docker.internal:9090/-/ready > /dev/null && echo "✓ Prometheus accessible via host.docker.internal" || echo "✗ Prometheus not accessible via host.docker.internal"
      
      # Final service verification
      echo "=== Service Verification ==="
      echo "If containers are running but not accessible, this is likely a network isolation issue in GitLab Runner"
      echo "Containers are running and healthy internally based on health checks"
      
      # Show logs for debugging
      echo "=== Recent Container Logs ==="
      docker logs prometheus --tail 20
      docker logs grafana --tail 20
      
      echo "=== Access Information ==="
      echo "Since this is running in GitLab's dind environment:"
      echo "- Containers are running and healthy internally"
      echo "- External access might be restricted by GitLab Runner networking"
      echo "- For actual monitoring, you would typically:"
      echo "  1. Deploy to a real environment"
      echo "  2. Use GitLab's environments feature"
      echo "  3. Or set up proper service tunneling"
      
      # Keep running for manual inspection
      echo "Monitoring stack will run for 10 minutes..."
      echo "Check GitLab job logs for any error messages above"
      sleep 600
  when: manual
  allow_failure: true
  timeout: 1 hour

deploy-job:
  stage: deploy
  environment: production
  script:
    - echo "Deploying application..."
    - echo "Application successfully deployed."
